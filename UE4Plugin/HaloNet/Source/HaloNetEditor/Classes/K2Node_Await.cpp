#include "HaloNetEditor.h"
#include "UObject/UnrealType.h"
#include "EdGraph/EdGraphPin.h"
#include "Kismet/KismetSystemLibrary.h"
#include "EdGraphSchema_K2.h"
#include "K2Node_CallFunction.h"
#include "K2Node_AssignmentStatement.h"
#include "K2Node_CustomEvent.h"
#include "K2Node_TemporaryVariable.h"
#include "KismetCompiler.h"
#include "BlueprintNodeSpawner.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "K2Node_Await.h"
#include "K2Node_GetDataTableRow.h"
#include "Mailbox.h"
#include "BlueprintEditorUtils.h"
#include "SGraphNode.h"
#include "ContentBrowserModule.h"
#include "Private/SAssetDialog.h"
#include "GraphEditorSettings.h"

#define LOCTEXT_NAMESPACE "K2Node_HN"

void UK2Node_HN_Await::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = Cast<UEdGraphSchema_K2>(GetSchema());

	CachedFunctionName = TEXT("...");

	if (K2Schema)
	{
		// CreatePin(EGPD_Input, K2Schema->PC_Exec, TEXT(""), nullptr, false, false, K2Schema->PN_Execute);
		CreatePin(EGPD_Input, K2Schema->PC_Exec, TEXT(""), nullptr, K2Schema->PN_Execute);
		// UEdGraphPin* OutputExecPin = CreatePin(EGPD_Output, K2Schema->PC_Exec, TEXT(""), nullptr, false, false, K2Schema->PN_Then);
		UEdGraphPin* OutputExecPin = CreatePin(EGPD_Output, K2Schema->PC_Exec, TEXT(""), nullptr, K2Schema->PN_Then);
		if (OutputExecPin)
		{
			OutputExecPin->PinFriendlyName = FText::FromName(K2Schema->PN_Completed);
		}

		CreatePin(EGPD_Input, K2Schema->PC_Object, TEXT(""), UMailbox::StaticClass(), TEXT("Target"));
	}
}

void UK2Node_HN_Await::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins)
{
	AllocateDefaultPins();

	ConstructMethodPinByMailbox(&OldPins);
	MailboxPinChanged(&OldPins);

	if (class UEdGraphPin* method_pin = FindPin(TEXT("Method")))
	{
		method_pin->DefaultValue = GetPinSpecified("Method", &OldPins)->DefaultValue;
		method_pin->AutogeneratedDefaultValue = GetPinSpecified("Method", &OldPins)->DefaultValue;
	}

	RestoreSplitPins(OldPins);
}

void UK2Node_HN_Await::PinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::PinConnectionListChanged(Pin);

	if (Pin->PinName == TEXT("Target"))
	{
		MailboxPinChanged();

		// Refresh the UI for the graph so the pin changes show up
		GetGraph()->NotifyGraphChanged();
		
		// Mark dirty
		FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
	}
}


UEdGraphPin* UK2Node_HN_Await::GetPinSpecified(FString PinName, TArray<UEdGraphPin*>* OldPins)
{
	if (OldPins != nullptr)
		for (auto& pin : *OldPins)
			if (pin->PinName == *PinName)
				return pin;
	return FindPin(PinName);
}

UClass* UK2Node_HN_Await::GetMailboxClass(TArray<UEdGraphPin*>* OldPins)
{
	UEdGraphPin* target_pin = GetPinSpecified("Target", OldPins);

	UClass* MailboxClass = nullptr;

	if (target_pin && target_pin->DefaultObject && target_pin->LinkedTo.Num() == 0)
	{
		MailboxClass = Cast<UClass>(target_pin->DefaultObject);
	}
	else if (target_pin && target_pin->LinkedTo.Num())
	{
		UEdGraphPin* ClassSource = target_pin->LinkedTo[0];
		MailboxClass = ClassSource ? Cast<UClass>(ClassSource->PinType.PinSubCategoryObject.Get()) : nullptr;
	}

	return MailboxClass;
}

UEdGraphPin* UK2Node_HN_Await::ConstructMethodPinByMailbox(TArray<UEdGraphPin*>* OldPins, bool bRemovePrevious)
{
	CachedMailboxName = TEXT("");

	const UEdGraphSchema_K2* K2Schema = Cast<UEdGraphSchema_K2>(GetSchema());

	UEdGraphPin* method_pin = nullptr;

	if (K2Schema)
	{
		UClass* MailboxClass = GetMailboxClass(OldPins);
		
		if (!MailboxClass)
			CachedFunctionName = TEXT("...");

		MailboxFunctionNames.Empty();
		if (MailboxClass)
		{

			CachedMailboxName = MailboxClass->GetName();
			for (auto func : TFieldRange<UFunction>(MailboxClass))
			{
				if (func->FunctionFlags & FUNC_BlueprintCallable)
				{
					if (auto latent_func = MailboxClass->FindFunctionByName(*FString::Printf(TEXT("internal_%s"), *func->GetName())))
					{
						if (auto ret_property = Cast<UObjectPropertyBase>(func->GetReturnProperty()))
						{
							if (ret_property->PropertyClass && ret_property->PropertyClass->IsChildOf<UFuture>())
							{
								MailboxFunctionNames.Add(*func->GetName());
							}
						}
					}
				}
			}
		}

		method_pin = GetPinSpecified(TEXT("Method"), OldPins);

		if (bRemovePrevious && method_pin && OldPins == nullptr)
			RemovePin(method_pin);

		if ((MailboxClass && MailboxClass != UMailbox::StaticClass() && method_pin == nullptr))
			method_pin = CreatePin(EGPD_Input, K2Schema->PC_Name, TEXT(""), nullptr, TEXT("Method"));
			// method_pin = CreatePin(EGPD_Input, K2Schema->PC_Name, TEXT(""), nullptr, false, false, TEXT("Method"), false, INDEX_NONE, false, false);

		if (OldPins != nullptr && !FindPin(TEXT("Method")))
		{
			auto new_method_pin = CreatePin(EGPD_Input, K2Schema->PC_Name, TEXT(""), nullptr, TEXT("Method"));
			// K2Schema->TrySetDefaultValue(*new_method_pin, method_pin->DefaultValue);
			// K2Schema->SetPinAutogeneratedDefaultValue(new_method_pin, method_pin->DefaultValue);
		}

		if (method_pin)
			method_pin->bHidden = false;
	}

	return method_pin;
}

void UK2Node_HN_Await::MailboxPinChanged(TArray<UEdGraphPin*>* OldPins)
{

	const UEdGraphSchema_K2* K2Schema = Cast<UEdGraphSchema_K2>(GetSchema());

	if (K2Schema)
	{
		UClass* MailboxClass = GetMailboxClass(OldPins);

		UFunction* func = nullptr;

		UEdGraphPin* method_pin = ConstructMethodPinByMailbox(OldPins, MailboxClass != CurrentMailboxClass || MailboxClass == nullptr);

		if (MailboxClass)
			func = GetMailboxFunction(MailboxClass, *method_pin->DefaultValue);


		if (func != CurrentFunction || MailboxClass != CurrentMailboxClass || func == nullptr || MailboxClass == nullptr)
		{
			// Clears all previous pins
			for (auto pin : CachedPins)
				RemovePin(pin);
			CachedPins.Empty();

			CurrentFunction = func;
			CurrentLatentFunction = func ? MailboxClass->FindFunctionByName(*FString::Printf(TEXT("internal_%s"), *func->GetName())) : nullptr;
			CurrentMailboxClass = MailboxClass;
		} else
		{
			return;
		}

		CachedMailboxName = TEXT("");

		if (MailboxClass)
		{
			CachedMailboxName = MailboxClass->GetName();

			method_pin->bHidden = false;

			if (func)
			{
				CachedFunctionName = method_pin->DefaultValue;
				const UObject* const ClassDefaultObject = MailboxClass->GetDefaultObject(false);

				UObjectPropertyBase* ReturnProperty = Cast<UObjectPropertyBase>(func->GetReturnProperty());

				CurrentInProperties.Empty();
				const TArray<UEdGraphPin*> in_pins = FindPropertiesAndGeneratePinsForAsyncFunction(func, EGPD_Input, CurrentInProperties);
				CachedPins.Append(in_pins);

				if (ReturnProperty)
				{
					CurrentOutProperties.Empty();
					UFunction* exec_func_return = ReturnProperty->PropertyClass->FindFunctionByName(TEXT("Execute"));
					const TArray<UEdGraphPin*> out_pins = FindPropertiesAndGeneratePinsForAsyncFunction(exec_func_return, EGPD_Output, CurrentOutProperties);
					CachedPins.Append(out_pins);
				}

			}
			else
			{

				CachedFunctionName = TEXT("...");
			}
		}
	}
}

UFunction* UK2Node_HN_Await::GetMailboxFunction(UClass* MailboxClass, FName FunctionName)
{
	if (MailboxClass)
		for (auto func : TFieldRange<UFunction>(MailboxClass))
			if (func->HasAllFunctionFlags(FUNC_BlueprintCallable))
				if (MailboxClass->FindFunctionByName(*FString::Printf(TEXT("internal_%s"), *func->GetName())))
					if (auto ret_property = Cast<UObjectPropertyBase>(func->GetReturnProperty()))
						if (ret_property->PropertyClass && ret_property->PropertyClass->IsChildOf<UFuture>())
							if (func->GetName() == FunctionName.ToString())
								return func;
	return nullptr;
}

TArray<UEdGraphPin*> UK2Node_HN_Await::FindPropertiesAndGeneratePinsForAsyncFunction(UFunction* func, EEdGraphPinDirection direction, TArray<UProperty*>& OutProperties, bool bOnlyFindProperties)
{
	TArray<UEdGraphPin*> OutPins;
	const UEdGraphSchema_K2* K2Schema = Cast<UEdGraphSchema_K2>(GetSchema());
	if (K2Schema && func)
	{
		UProperty* ReturnProperty = func->GetReturnProperty();
		for (TFieldIterator<UProperty> PropertyIt(func, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
		{
			UProperty* Property = *PropertyIt;
			if (*PropertyIt != ReturnProperty)
				if (FBlueprintEditorUtils::PropertyStillExists(Property))
				{
					OutProperties.Add(Property);
					if (!bOnlyFindProperties)
						// if (UEdGraphPin* Pin = CreatePin(direction, FString(), FString(), nullptr, Property->GetName()))
						if (UEdGraphPin* Pin = CreatePin(direction, TEXT(""), TEXT(""), nullptr, Property->GetFName()))
						{
							K2Schema->ConvertPropertyToPinType(Property, /*out*/ Pin->PinType);
							OutPins.Add(Pin);
						}
				}
		}
	}
	return OutPins;
}

void UK2Node_HN_Await::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	// TODO: Currently turned off due to reorganization of node from generated to customizable!

	// auto target_pin = FindPin("Target");
	auto method_pin = FindPin(TEXT("Method"));

	CurrentMailboxClass = GetMailboxClass();
	if (CurrentMailboxClass && method_pin)
	{
		CurrentFunction = GetMailboxFunction(CurrentMailboxClass, *method_pin->DefaultValue);

		CurrentLatentFunction = CurrentFunction ? CurrentMailboxClass->FindFunctionByName(*FString::Printf(TEXT("internal_%s"), *CurrentFunction->GetName())) : nullptr;
		CurrentInProperties.Empty();
		CurrentOutProperties.Empty();
		FindPropertiesAndGeneratePinsForAsyncFunction(CurrentFunction, EGPD_Input, CurrentInProperties, true);

		UObjectPropertyBase* ReturnProperty = Cast<UObjectPropertyBase>(CurrentFunction->GetReturnProperty());
		if (ReturnProperty)
			FindPropertiesAndGeneratePinsForAsyncFunction(ReturnProperty->PropertyClass->FindFunctionByName(TEXT("Execute")), EGPD_Output, CurrentOutProperties, true);
	}

	if (CurrentLatentFunction && CurrentMailboxClass)
	{

		const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();
		check(Schema);
		bool bIsErrorFree = true;
		const UEdGraphSchema_K2* K2Schema = Cast<UEdGraphSchema_K2>(GetSchema());
		// Create intermediate function call
		auto CallIntermediateFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
		CallIntermediateFunctionNode->FunctionReference.SetExternalMember(CurrentLatentFunction->GetFName(), CurrentMailboxClass);
		CallIntermediateFunctionNode->AllocateDefaultPins();

		// TArray<FString> retvals;
		// TMap<FString, UObject*> retclasses;
		// TMap<FString, bool> ret_bisarrays;
		// 
		// 
		// retvals.Add(TEXT("RetVal1"));
		// retclasses.Add(TEXT("RetVal1"), USessionBaseMailbox::StaticClass());
		// ret_bisarrays.Add(TEXT("RetVal1"), false);
		// 
		// retvals.Add(TEXT("RetVal2"));
		// retclasses.Add(TEXT("RetVal2"), FindObject<UEnum>(ANY_PACKAGE, TEXT("ELoginResult"), true));
		// ret_bisarrays.Add(TEXT("RetVal2"), false);
		// 
		// retvals.Add(TEXT("RetVal3"));
		// retclasses.Add(TEXT("RetVal3"), nullptr);
		// ret_bisarrays.Add(TEXT("RetVal3"), false);
		// 
		// 
		// 
		// TArray<FString> connectors;
		// 
		// connectors.Add(TEXT("username"));
		// connectors.Add(TEXT("password"));



		// connect to input exe
		{
			auto InputExePin = GetExecPin();
			auto CallFunctionInputExePin = CallIntermediateFunctionNode->GetExecPin();
			bIsErrorFree &= InputExePin && CallFunctionInputExePin && CompilerContext.MovePinLinksToIntermediate(*InputExePin, *CallFunctionInputExePin).CanSafeConnect();
		}

		TMap<FString, UK2Node_AssignmentStatement*> assignment_nodes_by_name;
		TArray<UK2Node_AssignmentStatement*>  assignment_nodes;
		/// RetVals assignment section

		for (auto& ret_property : CurrentOutProperties)
		{
			const FString retval_name = ret_property->GetName();

			UObject* Subcategory_object = nullptr;
			UProperty* InnerProperty = ret_property;
			bool is_array = false;
			if (auto as_array = Cast<UArrayProperty>(ret_property))
			{
				InnerProperty = as_array->Inner;
				is_array = true;
			}
			if (auto as_object = Cast<UObjectPropertyBase>(InnerProperty))
				Subcategory_object = as_object->PropertyClass;
			if (auto as_struct = Cast<UStructProperty>(InnerProperty))
				Subcategory_object = as_struct->Struct;
			if (auto as_enum = Cast<UEnumProperty>(InnerProperty))
				Subcategory_object = as_enum->GetEnum();

			// Create Local Variable (for RetVal1)
			auto PinCategory = FindPin(retval_name)->PinType.PinCategory;
			// TODO: Old: // UK2Node_TemporaryVariable* TempVarOutput = CompilerContext.SpawnInternalVariable(this, PinCategory, FString(""), retclasses[retval_name], ret_bisarrays[retval_name]);
			UK2Node_TemporaryVariable* TempVarOutput = CompilerContext.SpawnInternalVariable(this, PinCategory, NAME_None, Subcategory_object, is_array ? EPinContainerType::Array : EPinContainerType::None);
			// UK2Node_TemporaryVariable* TempVarOutput = CompilerContext.SpawnInternalVariable(this, PinCategory, FString(""), Subcategory_object, FEdGraphPinType::ToPinContainerType(is_array, false, false));

			// Create assign node (for RetVal1)
			UK2Node_AssignmentStatement* AssignNode = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
			assignment_nodes_by_name.Add(retval_name, AssignNode);
			assignment_nodes.Add(AssignNode);

			AssignNode->AllocateDefaultPins();


			auto RetVal_VariablePin = TempVarOutput->GetVariablePin();

			// connect local variable (for RetVal1) to assign node
			auto AssignLHSPPin = AssignNode->GetVariablePin();
			bIsErrorFree &= AssignLHSPPin && RetVal_VariablePin && Schema->TryCreateConnection(AssignLHSPPin, RetVal_VariablePin);

			// connect local variable (for RetVal1) to output
			auto OutputObjectPinPin = FindPin(retval_name);
			bIsErrorFree &= RetVal_VariablePin && OutputObjectPinPin && CompilerContext.MovePinLinksToIntermediate(*OutputObjectPinPin, *RetVal_VariablePin).CanSafeConnect();
		}

		auto SchemaThen = FindPin(Schema->PN_Then);
		auto FirstPin = CallIntermediateFunctionNode->FindPin(Schema->PN_Then);
		auto LastPin = SchemaThen;

		for (int32 i = 0; i < assignment_nodes.Num(); i++)
		{
			auto AssignNode = assignment_nodes[i];

			UEdGraphPin* PrevPin = (i == 0) ? FirstPin : assignment_nodes[i - 1]->GetThenPin();
			UEdGraphPin* NextPin = (i == assignment_nodes.Num() - 1) ? LastPin : assignment_nodes[i + 1]->GetThenPin();

			// connect assign (for RetVal1) exec input to function output
			auto AssignInputExePin = AssignNode->GetExecPin();
			bIsErrorFree &= AssignInputExePin && PrevPin && Schema->TryCreateConnection(AssignInputExePin, PrevPin);

			// auto AssignOutputExePin = AssignNode->GetThenPin();
			// bIsErrorFree &= NextPin && AssignOutputExePin && Schema->TryCreateConnection(NextPin, AssignOutputExePin);
			if (i == assignment_nodes.Num() - 1)
			{
				auto AssignInputThenPin = AssignNode->GetThenPin();
				bIsErrorFree &= AssignInputThenPin && LastPin && CompilerContext.MovePinLinksToIntermediate(*LastPin, *AssignInputThenPin).CanSafeConnect();
			}

		}




		/// END OF assignment sections


		// connect to Target
		auto CallIntermediateFunctionNodePin = CallIntermediateFunctionNode->FindPin(TEXT("Target"));
		{
			auto TargetPin = FindPin(TEXT("Target"));
			ensure(CallIntermediateFunctionNodePin);
			bIsErrorFree &= TargetPin && CallIntermediateFunctionNodePin && CompilerContext.MovePinLinksToIntermediate(*TargetPin, *CallIntermediateFunctionNodePin).CanSafeConnect();
		}

		// Iterate over all named parameters
		for (auto& prop : CurrentInProperties)
		{
			const FString connector_name = prop->GetName();
			auto IntermediatePin = CallIntermediateFunctionNode->FindPin(connector_name);
			auto Pin = FindPin(connector_name);
			ensure(IntermediatePin);
			bIsErrorFree &= Pin && IntermediatePin && CompilerContext.MovePinLinksToIntermediate(*Pin, *IntermediatePin).CanSafeConnect();
		}

		// Create OnLoadEvent
		const FString DelegateOnLoadedParamName(TEXT("OnDone"));
		auto OnDoneEventNode = CompilerContext.SpawnIntermediateEventNode<UK2Node_CustomEvent>(this, CallIntermediateFunctionNodePin, SourceGraph);
		OnDoneEventNode->CustomFunctionName = *FString::Printf(TEXT("OnDone_%s"), *CompilerContext.GetGuid(this));
		OnDoneEventNode->AllocateDefaultPins();
		{
			UFunction* AwaitFunction = CallIntermediateFunctionNode->GetTargetFunction();
			UDelegateProperty* AwaitDelegateProperty = AwaitFunction ? FindField<UDelegateProperty>(AwaitFunction, *DelegateOnLoadedParamName) : nullptr;
			UFunction* OnLoadedSignature = AwaitDelegateProperty ? AwaitDelegateProperty->SignatureFunction : nullptr;
			ensure(OnLoadedSignature);
			for (TFieldIterator<UProperty> PropIt(OnLoadedSignature); PropIt && (PropIt->PropertyFlags & CPF_Parm); ++PropIt)
			{
				const UProperty* Param = *PropIt;
				if (!Param->HasAnyPropertyFlags(CPF_OutParm) || Param->HasAnyPropertyFlags(CPF_ReferenceParm))
				{
					FEdGraphPinType PinType;
					bIsErrorFree &= Schema->ConvertPropertyToPinType(Param, /*out*/ PinType);
					bIsErrorFree &= (NULL != OnDoneEventNode->CreateUserDefinedPin(Param->GetFName(), PinType, EGPD_Output));
				}
			}
		}

		// connect delegate
		{
			auto CallFunctionDelegatePin = CallIntermediateFunctionNode->FindPin(DelegateOnLoadedParamName);
			ensure(CallFunctionDelegatePin);
			auto EventDelegatePin = OnDoneEventNode->FindPin(UK2Node_CustomEvent::DelegateOutputName);
			bIsErrorFree &= CallFunctionDelegatePin && EventDelegatePin && Schema->TryCreateConnection(CallFunctionDelegatePin, EventDelegatePin);
		}

		// connect awaited result from event to assign
		for (auto& pair : assignment_nodes_by_name)
		{
			auto RetValEventPin = OnDoneEventNode->FindPin(pair.Key);
			ensure(RetValEventPin);
			auto AssignRHSPPin = pair.Value->GetValuePin();
			bIsErrorFree &= AssignRHSPPin && RetValEventPin && Schema->TryCreateConnection(RetValEventPin, AssignRHSPPin);
		}

		if (!bIsErrorFree)
		{
			CompilerContext.MessageLog.Error(*LOCTEXT("InternalConnectionError", "K2Node_HN_Await: Internal connection error. @@").ToString(), this);
		}
	} else
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("InternalConnectionError", "K2Node_HN_Await: Internal connection error: failed to find latent function or mailbox @@").ToString(), this);
	}
	
	BreakAllNodeLinks();
}

FText UK2Node_HN_Await::GetTooltipText() const
{
	return FText::Format(LOCTEXT("Await::GetTooltipText", "await {0}:{1}"), FText::FromString(CachedMailboxName), FText::FromString(CachedFunctionName));
}

void UK2Node_HN_Await::PinDefaultValueChanged(UEdGraphPin* Pin)
{
	if (Pin->PinName == TEXT("Method"))
	{
		MailboxPinChanged();

		// Refresh the UI for the graph so the pin changes show up
		GetGraph()->NotifyGraphChanged();

		// Mark dirty
		FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
	}
}

FText UK2Node_HN_Await::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return FText::Format(LOCTEXT("Await::GetNodeTitle", "await {0}"), FText::FromString(CachedFunctionName));
}

bool UK2Node_HN_Await::IsCompatibleWithGraph(const UEdGraph* TargetGraph) const
{
	bool bIsCompatible = false;
	// Can only place events in ubergraphs and macros (other code will help prevent macros with latents from ending up in functions), and basicasync task creates an event node:
	EGraphType GraphType = TargetGraph->GetSchema()->GetGraphType(TargetGraph);
	if (GraphType == EGraphType::GT_Ubergraph || GraphType == EGraphType::GT_Macro)
	{
		bIsCompatible = true;
	}
	return bIsCompatible && Super::IsCompatibleWithGraph(TargetGraph);
}

FLinearColor UK2Node_HN_Await::GetNodeTitleColor() const
{
	return FLinearColor(1.f, 0.3, 0.3, 1.f);
}

FSlateIcon UK2Node_HN_Await::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(0.3f, 0.3f, 1.f, 1.f);
	static FSlateIcon Icon("EditorStyle", "GraphEditor.Timeline_16x");
	return Icon;
}

FName UK2Node_HN_Await::GetCornerIcon() const
{
	return TEXT("Graph.Latent.LatentIcon");
}

void UK2Node_HN_Await::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	// actions get registered under specific object-keys; the idea is that
	// actions might have to be updated (or deleted) if their object-key is
	// mutated (or removed)... here we use the node's class (so if the node
	// type disappears, then the action should go with it)
	UClass* ActionKey = GetClass();
	// to keep from needlessly instantiating a UBlueprintNodeSpawner, first
	// check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the
	// registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

FText UK2Node_HN_Await::GetMenuCategory() const
{
	return FText(LOCTEXT("Await", "Utilities"));
}

TSharedPtr<SGraphNode> UK2Node_HN_Await::CreateVisualWidget()
{

	return SNew(SK2Node_MethodsDropdown, this);
}




const UEdGraphSchema_K2* UK2Node_HN_Await::GetK2Schema()
{
	return CastChecked<UEdGraphSchema_K2>(GetSchema());
}

/// SK2Node_MethodsDropdown

SK2Node_MethodsDropdown::FArguments::FArguments()
{
	
}


void SK2Node_MethodsDropdown::Construct(const FArguments& InArgs, UK2Node_HN_Await* InNode)
{
	GraphNode = InNode;
	Names = InNode->MailboxFunctionNames;
	CurrentIcon = FSlateIcon();
	UpdateGraphNode();
}

void SK2Node_MethodsDropdown::CreateStandardPinWidget(UEdGraphPin* Pin)
{
	if (Pin->PinName == "Method")
	{
		CreateDetailsPickers();
	}
	else
	{
		SGraphNode::CreateStandardPinWidget(Pin);
	}
}

TSharedRef<SWidget> SK2Node_MethodsDropdown::GetPickerMenu()
{
	// Close self only to enable use inside context menus
	FMenuBuilder MenuBuilder(true, nullptr, nullptr, true);


	FSlateIcon Icon;

	for (auto name : Names)
	{
		MenuBuilder.AddMenuEntry(
			FText::FromName(name),
			FText(),
			Icon,
			FUIAction(
				FExecuteAction::CreateRaw(this, &SK2Node_MethodsDropdown::SetMethodName, name)
			)
		);
	}


	return MenuBuilder.MakeWidget();
}

void SK2Node_MethodsDropdown::OnAssetSelectedFromPicker(const FAssetData& AssetData)
{
	UpdateGraphNode();
}

FText SK2Node_MethodsDropdown::GetAssetName() const
{
	return FText(); 
}

void SK2Node_MethodsDropdown::CreateDetailsPickers()
{
	LeftNodeBox->AddSlot()
	           .AutoHeight()
	           .HAlign(HAlign_Left)
	           .VAlign(VAlign_Center)
	           .Padding(Settings->GetInputPinPadding())
	[
		SNew(SBox)
		.MaxDesiredWidth(200.0f)
		.Padding(FMargin(2, 0))
		[
			SNew(SComboButton)
			.ButtonStyle(FEditorStyle::Get(), "PropertyEditor.AssetComboStyle")
			// .ToolTipText(this, &SGraphNodeGetSequenceBinding::GetToolTipText)
			.ForegroundColor(this, &SK2Node_MethodsDropdown::OnGetComboForeground)
			.ButtonColorAndOpacity(this, &SK2Node_MethodsDropdown::OnGetWidgetBackground)
			.ContentPadding(FMargin(2, 2, 2, 1))
			.MenuPlacement(MenuPlacement_BelowAnchor)
			.ButtonContent()
			[
				/// 
				GetCurrentItemWidget(
					SNew(STextBlock)
					.TextStyle(FEditorStyle::Get(), "PropertyEditor.AssetClass")
					.Font(FEditorStyle::GetFontStyle("PropertyWindow.NormalFont"))
				)
				///
			]
			.OnGetMenuContent(this, &SK2Node_MethodsDropdown::GetPickerMenu)
		]
	];
}

TSharedRef<SWidget> SK2Node_MethodsDropdown::GetCurrentItemWidget(TSharedRef<STextBlock> TextContent)
{
	TextContent->SetText(TAttribute<FText>::Create(TAttribute<FText>::FGetter::CreateRaw(this, &SK2Node_MethodsDropdown::GetCurrentText)));

	return SNew(SHorizontalBox)
		+ SHorizontalBox::Slot()
		.AutoWidth()
		[
			SNew(SOverlay)
			+ SOverlay::Slot()
		[
			SNew(SImage)
			.Image_Raw(this, &SK2Node_MethodsDropdown::GetCurrentIconBrush)
		]

	+ SOverlay::Slot()
		.VAlign(VAlign_Top)
		.HAlign(HAlign_Right)
		[
			SNew(SImage)
			// .Visibility_Raw(this, &::GetSpawnableIconOverlayVisibility)
		.Image(FEditorStyle::GetBrush("Sequencer.SpawnableIconOverlay"))
		]
		]

	+ SHorizontalBox::Slot()
		.Padding(4.f, 0, 0, 0)
		.VAlign(VAlign_Center)
		[
			TextContent
		];
}

FText SK2Node_MethodsDropdown::GetCurrentText()
{
	if (auto node = Cast<UK2Node_HN_Await>(GraphNode))
		if (node->CurrentFunction)
			return node->CurrentFunction->GetDisplayNameText();
	
	return LOCTEXT("SelectMethod", "Select method");
}

const FSlateBrush* SK2Node_MethodsDropdown::GetCurrentIconBrush() const
{
	return CurrentIcon.GetOptionalIcon();
}

void SK2Node_MethodsDropdown::SetMethodName(FName InName)
{
	if (UEdGraphPin* method_pin = GraphNode->FindPin(TEXT("Method")))
	{
		const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

		K2Schema->TrySetDefaultValue(*method_pin, InName.ToString());
		K2Schema->SetPinAutogeneratedDefaultValue(method_pin, InName.ToString());
	}

}

FSlateColor SK2Node_MethodsDropdown::OnGetComboForeground() const
{
	return FSlateColor(FLinearColor(1.f, 1.f, 1.f, IsHovered() ? 1.f : 0.6f));
}

FSlateColor SK2Node_MethodsDropdown::OnGetWidgetForeground() const
{
	return FSlateColor(FLinearColor(1.f, 1.f, 1.f, IsHovered() ? 1.f : 0.15f));
}

FSlateColor SK2Node_MethodsDropdown::OnGetWidgetBackground() const
{
	return FSlateColor(FLinearColor(1.f, 1.f, 1.f, IsHovered() ? 0.8f : 0.4f));
}





#undef LOCTEXT_NAMESPACE
